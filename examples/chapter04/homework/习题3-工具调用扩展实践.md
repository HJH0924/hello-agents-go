# ä¹ é¢˜3ï¼šå·¥å…·è°ƒç”¨æ‰©å±•å®è·µ

## é—®é¢˜

å·¥å…·è°ƒç”¨æ˜¯ç°ä»£æ™ºèƒ½ä½“çš„æ ¸å¿ƒèƒ½åŠ›ä¹‹ä¸€ã€‚åŸºäº4.2.2èŠ‚çš„ `ToolExecutor` è®¾è®¡ï¼Œè¯·å®Œæˆä»¥ä¸‹æ‰©å±•å®è·µï¼š

1. ä¸º `ReAct` æ™ºèƒ½ä½“æ·»åŠ ä¸€ä¸ª"è®¡ç®—å™¨"å·¥å…·ï¼Œä½¿å…¶èƒ½å¤Ÿå¤„ç†å¤æ‚çš„æ•°å­¦è®¡ç®—é—®é¢˜ï¼ˆå¦‚"è®¡ç®— `(123 + 456) Ã— 789/ 12 = ?` çš„ç»“æœ"ï¼‰
2. è®¾è®¡å¹¶å®ç°ä¸€ä¸ª"å·¥å…·é€‰æ‹©å¤±è´¥"çš„å¤„ç†æœºåˆ¶ï¼šå½“æ™ºèƒ½ä½“å¤šæ¬¡è°ƒç”¨é”™è¯¯çš„å·¥å…·æˆ–æä¾›é”™è¯¯çš„å‚æ•°æ—¶ï¼Œç³»ç»Ÿåº”è¯¥å¦‚ä½•å¼•å¯¼å®ƒçº æ­£ï¼Ÿ
3. æ€è€ƒï¼šå¦‚æœå¯è°ƒç”¨å·¥å…·çš„æ•°é‡å¢åŠ åˆ°50ä¸ªç”šè‡³100ä¸ªï¼Œå½“å‰çš„å·¥å…·æè¿°æ–¹å¼æ˜¯å¦è¿˜èƒ½æœ‰æ•ˆå·¥ä½œï¼Ÿåœ¨å¯è°ƒç”¨å·¥å…·æ•°é‡éšä¸šåŠ¡éœ€æ±‚æ˜¾è‘—å¢åŠ æ—¶ï¼Œä»å·¥ç¨‹è§’åº¦å¦‚ä½•ä¼˜åŒ–å·¥å…·çš„ç»„ç»‡å’Œæ£€ç´¢æœºåˆ¶ï¼Ÿ

---

## å›ç­”

### 1. æ·»åŠ è®¡ç®—å™¨å·¥å…·

#### å·¥å…·å®ç°

```go
// calculator.go
package chapter04

import (
    "fmt"
    "github.com/Knetic/govaluate"
)

// CalculatorTool è®¡ç®—å™¨å·¥å…·ï¼Œç”¨äºæ‰§è¡Œæ•°å­¦è¡¨è¾¾å¼è®¡ç®—
func CalculatorTool(expression string) (string, error) {
    // ä½¿ç”¨ govaluate åº“è§£æå’Œè®¡ç®—æ•°å­¦è¡¨è¾¾å¼
    expr, err := govaluate.NewEvaluableExpression(expression)
    if err != nil {
        return "", fmt.Errorf("è¡¨è¾¾å¼è§£æå¤±è´¥: %w", err)
    }

    result, err := expr.Evaluate(nil)
    if err != nil {
        return "", fmt.Errorf("è®¡ç®—å¤±è´¥: %w", err)
    }

    return fmt.Sprintf("%v", result), nil
}

// æ³¨å†Œè®¡ç®—å™¨å·¥å…·
func RegisterCalculatorTool(executor *ToolExecutor) {
    executor.RegisterTool(
        "Calculator",
        "ä¸€ä¸ªç²¾ç¡®çš„æ•°å­¦è®¡ç®—å™¨ã€‚è¾“å…¥æ•°å­¦è¡¨è¾¾å¼ï¼Œè¿”å›è®¡ç®—ç»“æœã€‚æ”¯æŒåŠ å‡ä¹˜é™¤ã€æ‹¬å·ã€å¹‚è¿ç®—ç­‰ã€‚ç¤ºä¾‹ï¼š(123 + 456) * 789 / 12",
        CalculatorTool,
    )
}
```

#### æµ‹è¯•ç”¨ä¾‹

```go
// calculator_test.go
package chapter04

import (
	"context"
	"os"
	"testing"

	"github.com/sashabaranov/go-openai"
	"github.com/stretchr/testify/assert"
)

func TestCalculatorTool(t *testing.T) {
	tests := []struct {
		name       string
		expression string
		want       string
		wantErr    bool
	}{
		{
			name:       "ç®€å•åŠ æ³•",
			expression: "123 + 456",
			want:       "579",
			wantErr:    false,
		},
		{
			name:       "å¤æ‚è¡¨è¾¾å¼",
			expression: "(123 + 456) * 789 / 12",
			want:       "38069.25",
			wantErr:    false,
		},
		{
			name:       "å¹‚è¿ç®—",
			expression: "2 ** 10",
			want:       "1024",
			wantErr:    false,
		},
		{
			name:       "é”™è¯¯è¡¨è¾¾å¼",
			expression: "123 + + 456",
			wantErr:    true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result, err := CalculatorTool(tt.expression)
			if tt.wantErr {
				assert.Error(t, err)
			} else {
				assert.NoError(t, err)
				assert.Equal(t, tt.want, result)
			}
		})
	}
}

func TestReactAgentWithCalculator(t *testing.T) {
	// åˆå§‹åŒ–å·¥å…·æ‰§è¡Œå™¨
	toolExecutor := NewToolExecutor()

	// æ³¨å†Œè®¡ç®—å™¨å·¥å…·
	RegisterCalculatorTool(toolExecutor)

	// æ³¨å†Œæœç´¢å·¥å…·ï¼ˆå¯é€‰ï¼‰
	RegisterGoogleSearchTool(toolExecutor)

	// åˆå§‹åŒ–LLMå®¢æˆ·ç«¯
	llmClient := NewHelloAgentsLLM(
		openai.GPT4oMini,
		os.Getenv("OPENAI_API_KEY"),
		os.Getenv("OPENAI_BASE_URL"),
		60,
	)

	// åˆ›å»º ReAct Agent
	agent := NewReactAgent(llmClient, toolExecutor, 5)

	// æµ‹è¯•é—®é¢˜
	question := "è®¡ç®— (123 + 456) Ã— 789 / 12 çš„ç»“æœæ˜¯å¤šå°‘ï¼Ÿ"

	// è¿è¡Œ
	ctx := context.Background()
	answer, err := agent.Run(ctx, question)

	assert.NoError(t, err)
	assert.NotEmpty(t, answer)
	assert.Contains(t, answer, "38069") // éªŒè¯ç­”æ¡ˆä¸­åŒ…å«æ­£ç¡®ç»“æœ

	t.Logf("é—®é¢˜: %s", question)
	t.Logf("ç­”æ¡ˆ: %s", answer)
}
```

---

### 2. å·¥å…·é€‰æ‹©å¤±è´¥çš„å¤„ç†æœºåˆ¶

#### è®¾è®¡æ€è·¯

å½“æ™ºèƒ½ä½“å¤šæ¬¡è°ƒç”¨é”™è¯¯å·¥å…·æ—¶ï¼Œéœ€è¦ï¼š
1. **æ£€æµ‹å¤±è´¥æ¨¡å¼**ï¼šç»Ÿè®¡å·¥å…·è°ƒç”¨å¤±è´¥æ¬¡æ•°
2. **æä¾›åé¦ˆ**ï¼šåœ¨ Observation ä¸­æ˜ç¡®æŒ‡å‡ºé”™è¯¯
3. **å¼•å¯¼çº æ­£**ï¼šåœ¨æç¤ºè¯ä¸­åŠ å…¥çº é”™æŒ‡å¯¼

#### å®ç°

```go
// tool_failure_handler.go
package chapter04

import (
    "fmt"
    "strings"
)

// ToolFailureTracker å·¥å…·å¤±è´¥è¿½è¸ªå™¨
type ToolFailureTracker struct {
    failures map[string]int  // å·¥å…·å -> å¤±è´¥æ¬¡æ•°
    maxRetry int             // æœ€å¤§é‡è¯•æ¬¡æ•°
}

func NewToolFailureTracker(maxRetry int) *ToolFailureTracker {
    return &ToolFailureTracker{
        failures: make(map[string]int),
        maxRetry: maxRetry,
    }
}

// RecordFailure è®°å½•å¤±è´¥
func (t *ToolFailureTracker) RecordFailure(toolName string) {
    t.failures[toolName]++
}

// GetFailureCount è·å–å¤±è´¥æ¬¡æ•°
func (t *ToolFailureTracker) GetFailureCount(toolName string) int {
    return t.failures[toolName]
}

// ShouldBlock æ˜¯å¦åº”è¯¥é˜»æ­¢ç»§ç»­å°è¯•
func (t *ToolFailureTracker) ShouldBlock(toolName string) bool {
    return t.failures[toolName] >= t.maxRetry
}

// GetGuidance è·å–çº é”™æŒ‡å¯¼
func (t *ToolFailureTracker) GetGuidance(toolName string, error string) string {
    count := t.failures[toolName]

    guidance := fmt.Sprintf("å·¥å…· '%s' è°ƒç”¨å¤±è´¥ï¼ˆç¬¬%dæ¬¡ï¼‰ã€‚é”™è¯¯ï¼š%s\n", toolName, count, error)

    if count >= 2 {
        guidance += "\nå»ºè®®ï¼š\n"
        guidance += "1. æ£€æŸ¥å·¥å…·åç§°æ˜¯å¦æ­£ç¡®\n"
        guidance += "2. æ£€æŸ¥è¾“å…¥å‚æ•°æ ¼å¼æ˜¯å¦ç¬¦åˆè¦æ±‚\n"
        guidance += "3. è€ƒè™‘ä½¿ç”¨å…¶ä»–å·¥å…·å®Œæˆä»»åŠ¡\n"
    }

    if t.ShouldBlock(toolName) {
        guidance += fmt.Sprintf("\nè­¦å‘Šï¼šå·¥å…· '%s' å·²è¾¾åˆ°æœ€å¤§é‡è¯•æ¬¡æ•°(%d)ï¼Œè¯·ä½¿ç”¨å…¶ä»–å·¥å…·ã€‚\n", toolName, t.maxRetry)
    }

    return guidance
}
```

#### é›†æˆåˆ° ReAct Agent

```go
// åœ¨ ReactAgent ä¸­æ·»åŠ å¤±è´¥è¿½è¸ª
type ReactAgent struct {
    llmClient       *HelloAgentsLLM
    toolExecutor    *ToolExecutor
    failureTracker  *ToolFailureTracker  // æ–°å¢
    maxSteps        int
    history         []string
}

func NewReactAgent(llmClient *HelloAgentsLLM, toolExecutor *ToolExecutor, maxSteps int) *ReactAgent {
    return &ReactAgent{
        llmClient:      llmClient,
        toolExecutor:   toolExecutor,
        failureTracker: NewToolFailureTracker(3),  // æœ€å¤šé‡è¯•3æ¬¡
        maxSteps:       maxSteps,
        history:        []string{},
    }
}

// åœ¨ Run æ–¹æ³•ä¸­çš„å·¥å…·è°ƒç”¨éƒ¨åˆ†ä¿®æ”¹
func (a *ReactAgent) Run(ctx context.Context, question string) (string, error) {
    // ... å‰é¢çš„ä»£ç ä¿æŒä¸å˜ ...

    // è§£æå·¥å…·è°ƒç”¨
    toolName, toolInput := a.parseAction(action)
    if toolName == "" || toolInput == "" {
        a.history = append(a.history, "Observation: æ— æ•ˆçš„Actionæ ¼å¼ï¼Œè¯·æ£€æŸ¥ã€‚")
        continue
    }

    // æ£€æŸ¥æ˜¯å¦åº”è¯¥é˜»æ­¢ç»§ç»­å°è¯•è¿™ä¸ªå·¥å…·
    if a.failureTracker.ShouldBlock(toolName) {
        observation := fmt.Sprintf("å·¥å…· '%s' å·²è¢«é˜»æ­¢ä½¿ç”¨ï¼ˆå¤±è´¥æ¬¡æ•°è¿‡å¤šï¼‰ã€‚è¯·é€‰æ‹©å…¶ä»–å·¥å…·ã€‚", toolName)
        a.history = append(a.history, fmt.Sprintf("Observation: %s", observation))
        fmt.Printf("âŒ %s\n", observation)
        continue
    }

    fmt.Printf("ğŸ¬ è¡ŒåŠ¨: %s[%s]\n", toolName, toolInput)
    toolFunction, err := a.toolExecutor.GetToolCall(toolName)
    var observation string
    if err != nil {
        observation = fmt.Sprintf("é”™è¯¯ï¼šæœªæ‰¾åˆ°åä¸º '%s' çš„å·¥å…·ã€‚", toolName)
        a.failureTracker.RecordFailure(toolName)
        observation = a.failureTracker.GetGuidance(toolName, observation)
    } else {
        result, err := toolFunction(toolInput)
        if err != nil {
            observation = fmt.Sprintf("å·¥å…·æ‰§è¡Œé”™è¯¯: %v", err)
            a.failureTracker.RecordFailure(toolName)
            observation = a.failureTracker.GetGuidance(toolName, err.Error())
        } else {
            observation = result
        }
    }

    fmt.Printf("ğŸ‘€ è§‚å¯Ÿ: %s\n", observation)
    a.history = append(a.history, fmt.Sprintf("Action: %s", action))
    a.history = append(a.history, fmt.Sprintf("Observation: %s", observation))

    // ... åé¢çš„ä»£ç ä¿æŒä¸å˜ ...
}
```

---

### 3. å¤§è§„æ¨¡å·¥å…·çš„ç»„ç»‡å’Œæ£€ç´¢ä¼˜åŒ–

#### é—®é¢˜åˆ†æ

å½“å·¥å…·æ•°é‡å¢åŠ åˆ°50-100ä¸ªæ—¶ï¼š

**å½“å‰æ–¹æ¡ˆçš„é—®é¢˜**ï¼š
1. **æç¤ºè¯è¿‡é•¿**ï¼šæ‰€æœ‰å·¥å…·æè¿°éƒ½æ”¾å…¥æç¤ºè¯ï¼Œè¶…è¿‡ä¸Šä¸‹æ–‡é™åˆ¶
2. **é€‰æ‹©å›°éš¾**ï¼šLLMéš¾ä»¥ä»å¤§é‡å·¥å…·ä¸­å‡†ç¡®é€‰æ‹©
3. **æ£€ç´¢æ•ˆç‡ä½**ï¼šçº¿æ€§éå†æ‰€æœ‰å·¥å…·
4. **ç»´æŠ¤å›°éš¾**ï¼šå·¥å…·ç®¡ç†æ··ä¹±

#### ä¼˜åŒ–æ–¹æ¡ˆ

##### æ–¹æ¡ˆ1ï¼šåˆ†ç±»ç®¡ç† + ä¸¤é˜¶æ®µæ£€ç´¢

```go
// tool_category.go
package chapter04

type ToolCategory string

const (
    CategorySearch      ToolCategory = "æœç´¢"
    CategoryCalculation ToolCategory = "è®¡ç®—"
    CategoryData        ToolCategory = "æ•°æ®å¤„ç†"
    CategoryAPI         ToolCategory = "APIè°ƒç”¨"
    CategoryFile        ToolCategory = "æ–‡ä»¶æ“ä½œ"
)

type CategorizedTool struct {
    Name        string
    Description string
    Category    ToolCategory
    Tags        []string
    Call        func(string) (string, error)
}

type CategorizedToolExecutor struct {
    tools      map[string]*CategorizedTool
    categories map[ToolCategory][]*CategorizedTool
}

func NewCategorizedToolExecutor() *CategorizedToolExecutor {
    return &CategorizedToolExecutor{
        tools:      make(map[string]*CategorizedTool),
        categories: make(map[ToolCategory][]*CategorizedTool),
    }
}

func (e *CategorizedToolExecutor) RegisterTool(tool *CategorizedTool) {
    e.tools[tool.Name] = tool
    e.categories[tool.Category] = append(e.categories[tool.Category], tool)
}

// GetToolsByCategory æŒ‰ç±»åˆ«è·å–å·¥å…·
func (e *CategorizedToolExecutor) GetToolsByCategory(category ToolCategory) []*CategorizedTool {
    return e.categories[category]
}

// GetCategoryDescription è·å–ç±»åˆ«çš„ç®€è¦æè¿°
func (e *CategorizedToolExecutor) GetCategoryDescription() string {
    var desc strings.Builder
    desc.WriteString("å¯ç”¨å·¥å…·ç±»åˆ«ï¼š\n")
    for category, tools := range e.categories {
        desc.WriteString(fmt.Sprintf("- %s: %dä¸ªå·¥å…·\n", category, len(tools)))
    }
    return desc.String()
}

// GetToolsDescription åªè·å–ç‰¹å®šç±»åˆ«çš„å·¥å…·æè¿°
func (e *CategorizedToolExecutor) GetToolsDescription(category ToolCategory) string {
    tools := e.categories[category]
    var desc strings.Builder
    for _, tool := range tools {
        desc.WriteString(fmt.Sprintf("- %s: %s\n", tool.Name, tool.Description))
    }
    return desc.String()
}
```

**ä½¿ç”¨æ–¹å¼**ï¼š
1. ç¬¬ä¸€æ­¥ï¼šLLMå…ˆé€‰æ‹©å·¥å…·ç±»åˆ«
2. ç¬¬äºŒæ­¥ï¼šåªå±•ç¤ºè¯¥ç±»åˆ«çš„å·¥å…·ï¼ŒLLMé€‰æ‹©å…·ä½“å·¥å…·

##### æ–¹æ¡ˆ2ï¼šè¯­ä¹‰æ£€ç´¢ + å‘é‡æ•°æ®åº“

```go
// tool_semantic_search.go
package chapter04

import (
    "context"
    "sort"
)

type SemanticToolExecutor struct {
    tools          map[string]*CategorizedTool
    embeddings     map[string][]float64  // å·¥å…·æè¿°çš„å‘é‡è¡¨ç¤º
    embeddingModel EmbeddingModel        // å‘é‡åŒ–æ¨¡å‹
}

type EmbeddingModel interface {
    Embed(ctx context.Context, text string) ([]float64, error)
}

// SearchTools æ ¹æ®æŸ¥è¯¢è¯­ä¹‰æœç´¢æœ€ç›¸å…³çš„å·¥å…·
func (e *SemanticToolExecutor) SearchTools(ctx context.Context, query string, topK int) ([]*CategorizedTool, error) {
    // 1. è·å–æŸ¥è¯¢çš„å‘é‡è¡¨ç¤º
    queryEmbedding, err := e.embeddingModel.Embed(ctx, query)
    if err != nil {
        return nil, err
    }

    // 2. è®¡ç®—ä¸æ‰€æœ‰å·¥å…·çš„ç›¸ä¼¼åº¦
    type toolScore struct {
        tool  *CategorizedTool
        score float64
    }
    var scores []toolScore

    for toolName, toolEmbedding := range e.embeddings {
        similarity := cosineSimilarity(queryEmbedding, toolEmbedding)
        scores = append(scores, toolScore{
            tool:  e.tools[toolName],
            score: similarity,
        })
    }

    // 3. æ’åºå¹¶è¿”å› Top-K
    sort.Slice(scores, func(i, j int) bool {
        return scores[i].score > scores[j].score
    })

    var result []*CategorizedTool
    for i := 0; i < topK && i < len(scores); i++ {
        result = append(result, scores[i].tool)
    }

    return result, nil
}

func cosineSimilarity(a, b []float64) float64 {
    if len(a) != len(b) {
        return 0
    }

    var dot, normA, normB float64
    for i := range a {
        dot += a[i] * b[i]
        normA += a[i] * a[i]
        normB += b[i] * b[i]
    }

    return dot / (math.Sqrt(normA) * math.Sqrt(normB))
}
```

##### æ–¹æ¡ˆ3ï¼šå·¥å…·æè¿°æ¨¡æ¿ä¼˜åŒ–

```go
// ä¸ºå·¥å…·å®šä¹‰ç»“æ„åŒ–çš„æè¿°æ¨¡æ¿
type StructuredToolDescription struct {
    Name         string
    Summary      string   // ä¸€å¥è¯æ¦‚æ‹¬
    When         string   // ä»€ä¹ˆæ—¶å€™ä½¿ç”¨
    InputFormat  string   // è¾“å…¥æ ¼å¼
    OutputFormat string   // è¾“å‡ºæ ¼å¼
    Examples     []string // ä½¿ç”¨ç¤ºä¾‹
}

func (d *StructuredToolDescription) ToShortDescription() string {
    return fmt.Sprintf("%s: %s", d.Name, d.Summary)
}

func (d *StructuredToolDescription) ToDetailedDescription() string {
    var desc strings.Builder
    desc.WriteString(fmt.Sprintf("## %s\n", d.Name))
    desc.WriteString(fmt.Sprintf("**åŠŸèƒ½**: %s\n", d.Summary))
    desc.WriteString(fmt.Sprintf("**ä½¿ç”¨åœºæ™¯**: %s\n", d.When))
    desc.WriteString(fmt.Sprintf("**è¾“å…¥æ ¼å¼**: %s\n", d.InputFormat))
    desc.WriteString(fmt.Sprintf("**è¾“å‡ºæ ¼å¼**: %s\n", d.OutputFormat))
    if len(d.Examples) > 0 {
        desc.WriteString("**ç¤ºä¾‹**:\n")
        for _, example := range d.Examples {
            desc.WriteString(fmt.Sprintf("  - %s\n", example))
        }
    }
    return desc.String()
}
```

#### ç»¼åˆä¼˜åŒ–ç­–ç•¥

```go
type OptimizedToolManager struct {
    categorized *CategorizedToolExecutor
    semantic    *SemanticToolExecutor
}

// æ™ºèƒ½å·¥å…·æ¨èæµç¨‹
func (m *OptimizedToolManager) RecommendTools(ctx context.Context, task string) ([]string, error) {
    // 1. è¯­ä¹‰æœç´¢æ‰¾åˆ°æœ€ç›¸å…³çš„5ä¸ªå·¥å…·
    relevant, err := m.semantic.SearchTools(ctx, task, 5)
    if err != nil {
        return nil, err
    }

    // 2. åªè¿”å›è¿™äº›å·¥å…·çš„ç®€çŸ­æè¿°
    var descriptions []string
    for _, tool := range relevant {
        descriptions = append(descriptions, tool.Description)
    }

    return descriptions, nil
}
```

---

## æ€»ç»“

**å®è·µè¦ç‚¹**ï¼š

1. **è®¡ç®—å™¨å·¥å…·**ï¼š
   - ä½¿ç”¨ `govaluate` åº“å®‰å…¨è§£æè¡¨è¾¾å¼
   - æä¾›æ¸…æ™°çš„å·¥å…·æè¿°
   - åŒ…å«ä½¿ç”¨ç¤ºä¾‹

2. **å¤±è´¥å¤„ç†æœºåˆ¶**ï¼š
   - è¿½è¸ªå¤±è´¥æ¬¡æ•°
   - æä¾›æ¸è¿›å¼æŒ‡å¯¼
   - è®¾ç½®é‡è¯•ä¸Šé™

3. **å¤§è§„æ¨¡å·¥å…·ä¼˜åŒ–**ï¼š
   - åˆ†ç±»ç®¡ç†ï¼šå‡å°‘æç¤ºè¯é•¿åº¦
   - è¯­ä¹‰æ£€ç´¢ï¼šç²¾å‡†æ¨èå·¥å…·
   - ç»“æ„åŒ–æè¿°ï¼šç»Ÿä¸€ç®¡ç†è§„èŒƒ

**æœ€ä½³å®è·µ**ï¼š
- 50ä¸ªä»¥å†…ï¼šåˆ†ç±»ç®¡ç†å³å¯
- 100ä¸ªä»¥ä¸Šï¼šå¿…é¡»ä½¿ç”¨è¯­ä¹‰æ£€ç´¢
- æŒç»­ä¼˜åŒ–ï¼šæ ¹æ®å®é™…ä½¿ç”¨ç»Ÿè®¡è°ƒæ•´
