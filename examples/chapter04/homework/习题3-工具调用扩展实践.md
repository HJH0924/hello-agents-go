# 习题3：工具调用扩展实践

## 问题

工具调用是现代智能体的核心能力之一。基于4.2.2节的 `ToolExecutor` 设计，请完成以下扩展实践：

1. 为 `ReAct` 智能体添加一个"计算器"工具，使其能够处理复杂的数学计算问题（如"计算 `(123 + 456) × 789/ 12 = ?` 的结果"）
2. 设计并实现一个"工具选择失败"的处理机制：当智能体多次调用错误的工具或提供错误的参数时，系统应该如何引导它纠正？
3. 思考：如果可调用工具的数量增加到50个甚至100个，当前的工具描述方式是否还能有效工作？在可调用工具数量随业务需求显著增加时，从工程角度如何优化工具的组织和检索机制？

---

## 回答

### 1. 添加计算器工具

#### 工具实现

```go
// calculator.go
package chapter04

import (
    "fmt"
    "github.com/Knetic/govaluate"
)

// CalculatorTool 计算器工具，用于执行数学表达式计算
func CalculatorTool(expression string) (string, error) {
    // 使用 govaluate 库解析和计算数学表达式
    expr, err := govaluate.NewEvaluableExpression(expression)
    if err != nil {
        return "", fmt.Errorf("表达式解析失败: %w", err)
    }

    result, err := expr.Evaluate(nil)
    if err != nil {
        return "", fmt.Errorf("计算失败: %w", err)
    }

    return fmt.Sprintf("%v", result), nil
}

// 注册计算器工具
func RegisterCalculatorTool(executor *ToolExecutor) {
    executor.RegisterTool(
        "Calculator",
        "一个精确的数学计算器。输入数学表达式，返回计算结果。支持加减乘除、括号、幂运算等。示例：(123 + 456) * 789 / 12",
        CalculatorTool,
    )
}
```

#### 测试用例

```go
// calculator_test.go
package chapter04

import (
	"context"
	"os"
	"testing"

	"github.com/sashabaranov/go-openai"
	"github.com/stretchr/testify/assert"
)

func TestCalculatorTool(t *testing.T) {
	tests := []struct {
		name       string
		expression string
		want       string
		wantErr    bool
	}{
		{
			name:       "简单加法",
			expression: "123 + 456",
			want:       "579",
			wantErr:    false,
		},
		{
			name:       "复杂表达式",
			expression: "(123 + 456) * 789 / 12",
			want:       "38069.25",
			wantErr:    false,
		},
		{
			name:       "幂运算",
			expression: "2 ** 10",
			want:       "1024",
			wantErr:    false,
		},
		{
			name:       "错误表达式",
			expression: "123 + + 456",
			wantErr:    true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result, err := CalculatorTool(tt.expression)
			if tt.wantErr {
				assert.Error(t, err)
			} else {
				assert.NoError(t, err)
				assert.Equal(t, tt.want, result)
			}
		})
	}
}

func TestReactAgentWithCalculator(t *testing.T) {
	// 初始化工具执行器
	toolExecutor := NewToolExecutor()

	// 注册计算器工具
	RegisterCalculatorTool(toolExecutor)

	// 注册搜索工具（可选）
	RegisterGoogleSearchTool(toolExecutor)

	// 初始化LLM客户端
	llmClient := NewHelloAgentsLLM(
		openai.GPT4oMini,
		os.Getenv("OPENAI_API_KEY"),
		os.Getenv("OPENAI_BASE_URL"),
		60,
	)

	// 创建 ReAct Agent
	agent := NewReactAgent(llmClient, toolExecutor, 5)

	// 测试问题
	question := "计算 (123 + 456) × 789 / 12 的结果是多少？"

	// 运行
	ctx := context.Background()
	answer, err := agent.Run(ctx, question)

	assert.NoError(t, err)
	assert.NotEmpty(t, answer)
	assert.Contains(t, answer, "38069") // 验证答案中包含正确结果

	t.Logf("问题: %s", question)
	t.Logf("答案: %s", answer)
}
```

---

### 2. 工具选择失败的处理机制

#### 设计思路

当智能体多次调用错误工具时，需要：
1. **检测失败模式**：统计工具调用失败次数
2. **提供反馈**：在 Observation 中明确指出错误
3. **引导纠正**：在提示词中加入纠错指导

#### 实现

```go
// tool_failure_handler.go
package chapter04

import (
    "fmt"
    "strings"
)

// ToolFailureTracker 工具失败追踪器
type ToolFailureTracker struct {
    failures map[string]int  // 工具名 -> 失败次数
    maxRetry int             // 最大重试次数
}

func NewToolFailureTracker(maxRetry int) *ToolFailureTracker {
    return &ToolFailureTracker{
        failures: make(map[string]int),
        maxRetry: maxRetry,
    }
}

// RecordFailure 记录失败
func (t *ToolFailureTracker) RecordFailure(toolName string) {
    t.failures[toolName]++
}

// GetFailureCount 获取失败次数
func (t *ToolFailureTracker) GetFailureCount(toolName string) int {
    return t.failures[toolName]
}

// ShouldBlock 是否应该阻止继续尝试
func (t *ToolFailureTracker) ShouldBlock(toolName string) bool {
    return t.failures[toolName] >= t.maxRetry
}

// GetGuidance 获取纠错指导
func (t *ToolFailureTracker) GetGuidance(toolName string, error string) string {
    count := t.failures[toolName]

    guidance := fmt.Sprintf("工具 '%s' 调用失败（第%d次）。错误：%s\n", toolName, count, error)

    if count >= 2 {
        guidance += "\n建议：\n"
        guidance += "1. 检查工具名称是否正确\n"
        guidance += "2. 检查输入参数格式是否符合要求\n"
        guidance += "3. 考虑使用其他工具完成任务\n"
    }

    if t.ShouldBlock(toolName) {
        guidance += fmt.Sprintf("\n警告：工具 '%s' 已达到最大重试次数(%d)，请使用其他工具。\n", toolName, t.maxRetry)
    }

    return guidance
}
```

#### 集成到 ReAct Agent

```go
// 在 ReactAgent 中添加失败追踪
type ReactAgent struct {
    llmClient       *HelloAgentsLLM
    toolExecutor    *ToolExecutor
    failureTracker  *ToolFailureTracker  // 新增
    maxSteps        int
    history         []string
}

func NewReactAgent(llmClient *HelloAgentsLLM, toolExecutor *ToolExecutor, maxSteps int) *ReactAgent {
    return &ReactAgent{
        llmClient:      llmClient,
        toolExecutor:   toolExecutor,
        failureTracker: NewToolFailureTracker(3),  // 最多重试3次
        maxSteps:       maxSteps,
        history:        []string{},
    }
}

// 在 Run 方法中的工具调用部分修改
func (a *ReactAgent) Run(ctx context.Context, question string) (string, error) {
    // ... 前面的代码保持不变 ...

    // 解析工具调用
    toolName, toolInput := a.parseAction(action)
    if toolName == "" || toolInput == "" {
        a.history = append(a.history, "Observation: 无效的Action格式，请检查。")
        continue
    }

    // 检查是否应该阻止继续尝试这个工具
    if a.failureTracker.ShouldBlock(toolName) {
        observation := fmt.Sprintf("工具 '%s' 已被阻止使用（失败次数过多）。请选择其他工具。", toolName)
        a.history = append(a.history, fmt.Sprintf("Observation: %s", observation))
        fmt.Printf("❌ %s\n", observation)
        continue
    }

    fmt.Printf("🎬 行动: %s[%s]\n", toolName, toolInput)
    toolFunction, err := a.toolExecutor.GetToolCall(toolName)
    var observation string
    if err != nil {
        observation = fmt.Sprintf("错误：未找到名为 '%s' 的工具。", toolName)
        a.failureTracker.RecordFailure(toolName)
        observation = a.failureTracker.GetGuidance(toolName, observation)
    } else {
        result, err := toolFunction(toolInput)
        if err != nil {
            observation = fmt.Sprintf("工具执行错误: %v", err)
            a.failureTracker.RecordFailure(toolName)
            observation = a.failureTracker.GetGuidance(toolName, err.Error())
        } else {
            observation = result
        }
    }

    fmt.Printf("👀 观察: %s\n", observation)
    a.history = append(a.history, fmt.Sprintf("Action: %s", action))
    a.history = append(a.history, fmt.Sprintf("Observation: %s", observation))

    // ... 后面的代码保持不变 ...
}
```

---

### 3. 大规模工具的组织和检索优化

#### 问题分析

当工具数量增加到50-100个时：

**当前方案的问题**：
1. **提示词过长**：所有工具描述都放入提示词，超过上下文限制
2. **选择困难**：LLM难以从大量工具中准确选择
3. **检索效率低**：线性遍历所有工具
4. **维护困难**：工具管理混乱

#### 优化方案

##### 方案1：分类管理 + 两阶段检索

```go
// tool_category.go
package chapter04

type ToolCategory string

const (
    CategorySearch      ToolCategory = "搜索"
    CategoryCalculation ToolCategory = "计算"
    CategoryData        ToolCategory = "数据处理"
    CategoryAPI         ToolCategory = "API调用"
    CategoryFile        ToolCategory = "文件操作"
)

type CategorizedTool struct {
    Name        string
    Description string
    Category    ToolCategory
    Tags        []string
    Call        func(string) (string, error)
}

type CategorizedToolExecutor struct {
    tools      map[string]*CategorizedTool
    categories map[ToolCategory][]*CategorizedTool
}

func NewCategorizedToolExecutor() *CategorizedToolExecutor {
    return &CategorizedToolExecutor{
        tools:      make(map[string]*CategorizedTool),
        categories: make(map[ToolCategory][]*CategorizedTool),
    }
}

func (e *CategorizedToolExecutor) RegisterTool(tool *CategorizedTool) {
    e.tools[tool.Name] = tool
    e.categories[tool.Category] = append(e.categories[tool.Category], tool)
}

// GetToolsByCategory 按类别获取工具
func (e *CategorizedToolExecutor) GetToolsByCategory(category ToolCategory) []*CategorizedTool {
    return e.categories[category]
}

// GetCategoryDescription 获取类别的简要描述
func (e *CategorizedToolExecutor) GetCategoryDescription() string {
    var desc strings.Builder
    desc.WriteString("可用工具类别：\n")
    for category, tools := range e.categories {
        desc.WriteString(fmt.Sprintf("- %s: %d个工具\n", category, len(tools)))
    }
    return desc.String()
}

// GetToolsDescription 只获取特定类别的工具描述
func (e *CategorizedToolExecutor) GetToolsDescription(category ToolCategory) string {
    tools := e.categories[category]
    var desc strings.Builder
    for _, tool := range tools {
        desc.WriteString(fmt.Sprintf("- %s: %s\n", tool.Name, tool.Description))
    }
    return desc.String()
}
```

**使用方式**：
1. 第一步：LLM先选择工具类别
2. 第二步：只展示该类别的工具，LLM选择具体工具

##### 方案2：语义检索 + 向量数据库

```go
// tool_semantic_search.go
package chapter04

import (
    "context"
    "sort"
)

type SemanticToolExecutor struct {
    tools          map[string]*CategorizedTool
    embeddings     map[string][]float64  // 工具描述的向量表示
    embeddingModel EmbeddingModel        // 向量化模型
}

type EmbeddingModel interface {
    Embed(ctx context.Context, text string) ([]float64, error)
}

// SearchTools 根据查询语义搜索最相关的工具
func (e *SemanticToolExecutor) SearchTools(ctx context.Context, query string, topK int) ([]*CategorizedTool, error) {
    // 1. 获取查询的向量表示
    queryEmbedding, err := e.embeddingModel.Embed(ctx, query)
    if err != nil {
        return nil, err
    }

    // 2. 计算与所有工具的相似度
    type toolScore struct {
        tool  *CategorizedTool
        score float64
    }
    var scores []toolScore

    for toolName, toolEmbedding := range e.embeddings {
        similarity := cosineSimilarity(queryEmbedding, toolEmbedding)
        scores = append(scores, toolScore{
            tool:  e.tools[toolName],
            score: similarity,
        })
    }

    // 3. 排序并返回 Top-K
    sort.Slice(scores, func(i, j int) bool {
        return scores[i].score > scores[j].score
    })

    var result []*CategorizedTool
    for i := 0; i < topK && i < len(scores); i++ {
        result = append(result, scores[i].tool)
    }

    return result, nil
}

func cosineSimilarity(a, b []float64) float64 {
    if len(a) != len(b) {
        return 0
    }

    var dot, normA, normB float64
    for i := range a {
        dot += a[i] * b[i]
        normA += a[i] * a[i]
        normB += b[i] * b[i]
    }

    return dot / (math.Sqrt(normA) * math.Sqrt(normB))
}
```

##### 方案3：工具描述模板优化

```go
// 为工具定义结构化的描述模板
type StructuredToolDescription struct {
    Name         string
    Summary      string   // 一句话概括
    When         string   // 什么时候使用
    InputFormat  string   // 输入格式
    OutputFormat string   // 输出格式
    Examples     []string // 使用示例
}

func (d *StructuredToolDescription) ToShortDescription() string {
    return fmt.Sprintf("%s: %s", d.Name, d.Summary)
}

func (d *StructuredToolDescription) ToDetailedDescription() string {
    var desc strings.Builder
    desc.WriteString(fmt.Sprintf("## %s\n", d.Name))
    desc.WriteString(fmt.Sprintf("**功能**: %s\n", d.Summary))
    desc.WriteString(fmt.Sprintf("**使用场景**: %s\n", d.When))
    desc.WriteString(fmt.Sprintf("**输入格式**: %s\n", d.InputFormat))
    desc.WriteString(fmt.Sprintf("**输出格式**: %s\n", d.OutputFormat))
    if len(d.Examples) > 0 {
        desc.WriteString("**示例**:\n")
        for _, example := range d.Examples {
            desc.WriteString(fmt.Sprintf("  - %s\n", example))
        }
    }
    return desc.String()
}
```

#### 综合优化策略

```go
type OptimizedToolManager struct {
    categorized *CategorizedToolExecutor
    semantic    *SemanticToolExecutor
}

// 智能工具推荐流程
func (m *OptimizedToolManager) RecommendTools(ctx context.Context, task string) ([]string, error) {
    // 1. 语义搜索找到最相关的5个工具
    relevant, err := m.semantic.SearchTools(ctx, task, 5)
    if err != nil {
        return nil, err
    }

    // 2. 只返回这些工具的简短描述
    var descriptions []string
    for _, tool := range relevant {
        descriptions = append(descriptions, tool.Description)
    }

    return descriptions, nil
}
```

---

## 总结

**实践要点**：

1. **计算器工具**：
   - 使用 `govaluate` 库安全解析表达式
   - 提供清晰的工具描述
   - 包含使用示例

2. **失败处理机制**：
   - 追踪失败次数
   - 提供渐进式指导
   - 设置重试上限

3. **大规模工具优化**：
   - 分类管理：减少提示词长度
   - 语义检索：精准推荐工具
   - 结构化描述：统一管理规范

**最佳实践**：
- 50个以内：分类管理即可
- 100个以上：必须使用语义检索
- 持续优化：根据实际使用统计调整
